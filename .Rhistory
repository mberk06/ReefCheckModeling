plot(pred, test[,y], main=paste(c(y,'predicted against true')), xlab='yhat', ylab='y')
abline(lm(test[,y] ~ pred), col="red") # regression line (y~x)
par(mfrow=c(1,1,))
par(mfrow=c(1,1))
plot(pred, test[,y], main=paste(c(y,'predicted against true')), xlab='yhat', ylab='y')
abline(lm(test[,y] ~ pred), col="red") # regression line (y~x)
text(x = 8, y = max(test[,y])-10, corStr, col = 'red', cex=0.8)#labels=paste0(c('r^2: ',rsquare)))
qqplot(pred, test[,y], main='Lobster qqplot Predicted vs. True', xlab='Predicted y', ylab="True y")
qqplot(pred, test[,y], main=paste0(y, 'qqplot Predicted vs. True'), xlab='Predicted y', ylab="True y")
qqplot(pred, test[,y], main=paste0('Butterfly Fish qqplot Predicted vs. True'), xlab='Predicted y', ylab="True y")
# variable importance and PDP
if (printAll) varImpPlot(fit)
par(mfrow=c(2,2))
xs <- unlist(strsplit(xs, "[+]"))
#if (xs[i] %in% c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {}
if (xs[i] %in% c("PARROTFISH", "DIADEMA","SNAPPER","GROUPER")) {
partialPlot(fit, train[!is.na(train[,xs[i]]),], xs[i],
xlab = xs[i], ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", xs[i])),
cex.main=0.8,
cex.lab=0.7)
}
for (i in 1:length(xs)) {
#if (xs[i] %in% c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {}
if (xs[i] %in% c("PARROTFISH", "DIADEMA","SNAPPER","GROUPER")) {
partialPlot(fit, train[!is.na(train[,xs[i]]),], xs[i],
xlab = xs[i], ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", xs[i])),
cex.main=0.8,
cex.lab=0.7)
}
}
plot(df)
par(mfrow=c(2,2))
xs <- unlist(strsplit(xs, "[+]"))
for (i in 1:length(xs)) {
#if (xs[i] %in% c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {}
if (xs[i] %in% c("PARROTFISH", "DIADEMA","SNAPPER","GROUPER.TOTAL")) {
partialPlot(fit, train[!is.na(train[,xs[i]]),], xs[i],
xlab = xs[i], ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", xs[i])),
cex.main=0.8,
cex.lab=0.7)
}
}
# variable importance and PDP
if (printAll) varImpPlot(fit)
# variable importance and PDP
if (printAll) varImpPlot(fit)
# variable importance and PDP
if (printAll) varImpPlot(fit)
# variable importance and PDP
if (printAll) varImpPlot(fit)
par(mfrow=c(1,1))
# variable importance and PDP
if (printAll) varImpPlot(fit)
if (PDP) {
par(mfrow=c(2,2))
xs <- unlist(strsplit(xs, "[+]"))
for (i in 1:length(xs)) {
#if (xs[i] %in% c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {}
if (xs[i] %in% c("PARROTFISH", "DIADEMA","SNAPPER","GROUPER.TOTAL")) {
partialPlot(fit, train[!is.na(train[,xs[i]]),], xs[i],
xlab = xs[i], ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", xs[i])),
cex.main=0.8,
cex.lab=0.7)
}
}
return (data.frame(y = test[,y], yPred = pred))
}
##########################
##########################
# TS
##########################
##########################
timeSeries <- function(df, y, h, lm=T, aa=T) {
#' perform linear regression/auto.arima using one column and/or date,
#' print model summary for lm/auto.arima
#'
#' @param df full dataframe with all columns (dataframe)
#' @param y response variable (character)
#' @param h number of days to forecast in the future (int)
#' @param lm run linear model (bool)
#' @param aa run autoarima model (bool)
# round response variable and remove
if (y %in% c(subsetCols('organism'))) {
df[,y] <- as.integer(round(df[,y])) # round all counts
}
df <- subset(df, !is.na(df[,y])) # drop na in y var
# create train and test split
if (is.Date(df$DATE)) {
train = subset(df, df$DATE < "2016-08-09")
test = subset(df, df$DATE >= "2016-08-09")
} else {
train = subset(df, df$DATE < 2016)
test = subset(df, df$DATE >= 2017)
}
##########
# run lm
if (lm) {
print("Linear Model...")
# train model
fit <- lm(get(y) ~ DATE, data = train)
print(paste0(c("Date coefficient", fit$coefficients[[2]]), collapse = ": "))
#print(paste0(c("Adjusted R-Squared", summary(fit)[[9]]), collapse = ": "))
print(round(cor(train[,y], fit$fitted.values),3))
# get preds
pred <- round(predict(fit, newdata=test))
# check if coef is too small to create preds
if (all(pred == pred[1])) {
print("All preds for lm are the same (coefficient too small)")
} else {
# get correlation
rsquare <- cor(pred, test[,y], use = "complete.obs")
corStr = paste0(c('Testing Correlation',round(rsquare, 3)), collapse = ': ')
print(corStr)
# plot output
plot(pred, test[,y], main=paste(c(y,'predicted against true')), xlab='yhat', ylab='y')
abline(lm(test[,y] ~ pred), col="red") # regression line (y~x)
text(x = 8, y = max(test[,y])-10, corStr, col = 'red', cex=0.8)#labels=paste0(c('r^2: ',rsquare)))
qqplot(pred, test[,y])
print('-------------------------')
}
}
##########
# run autoarima
if (aa) {
print("Auto ARIMA...")
# train
aaFit <- auto.arima(train[,y])
#print(summary(aaFit))
# get preds
aaPreds <- forecast(aaFit,h=h)
plot(aaPreds)
# get traning accuracy
#print(paste0(c("Training Accuracy: ", accuracy(aaPreds))))
print(paste0(c("Training Correlation", round(cor(train[,y], aaFit$fitted), 3), collapse = ": ")))
# get testing accuracy
if (dim(test)[1] >= h) {
print(paste0(c("Testing Correlation: ", round(cor(test[1:h,y], aaPreds$mean),3))))
}
}
}
par(mfrow=c(2,2))
xs <- unlist(strsplit(xs, "[+]"))
for (i in 1:length(xs)) {
#if (xs[i] %in% c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {}
if (xs[i] %in% c("PARROTFISH", "DIADEMA","SNAPPER","GROUPER.TOTAL")) {
partialPlot(fit, train[!is.na(train[,xs[i]]),], xs[i],
xlab = xs[i], ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", xs[i])),
cex.main=0.8,
cex.lab=0.7)
}
}
for (i in 1:length(xs)) {
#if (xs[i] %in% c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {}
if (xs[i] %in% c("PARROTFISH", "DIADEMA","SNAPPER","GROUPER.TOTAL")) {
partialPlot(fit, train[!is.na(train[,xs[i]]),], xs[i],
xlab = xs[i], ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", xs[i])),
cex.main=1.2,
cex.lab=1.2)
}
}
######################
# Pois/ZIP
######################
# setup xs and y (only change these lines)
df <- dfo
xs <- a
#xs <- b[b != "AQUARIUM.FISH.COLLECTION"] # o, a, b
y <- 'LOBSTER'
# round response variable and remove
if (y %in% c(subsetCols('organism'))) {
df[,y] <- as.integer(round(df[,y])) # round all counts
}
df <- subset(df, !is.na(df[,y])) # drop na in y var
xs <- xs[!xs %in% c(y)] # remove var from formula
# create formula
xs <- paste(xs, collapse="+")
formula <- formula(paste(c(y, xs), collapse='~'))
if (printAll) print(formula)
# create train and test split
sample = sample.split(df[,y], SplitRatio = .75)
train = subset(df, sample == TRUE)
test  = subset(df, sample == FALSE)
# run model
fit <- randomForest(formula, data = train, na.action=na.roughfix)
y
fit
ofrmula
formula
par(mfrow=c(2,2))
xs <- unlist(strsplit(xs, "[+]"))
for (i in 1:length(xs)) {
if (xs[i] %in% c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {
#if (xs[i] %in% c("PARROTFISH", "DIADEMA","SNAPPER","GROUPER.TOTAL")) {
partialPlot(fit, train[!is.na(train[,xs[i]]),], xs[i],
xlab = xs[i], ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", xs[i])),
cex.main=1.2,
cex.lab=1.2)
}
}
######################
# Pois/ZIP
######################
# setup xs and y (only change these lines)
df <- dfo
xs <- a
xs <- b
#xs <- b[b != "AQUARIUM.FISH.COLLECTION"] # o, a, b
y <- 'SNAPPER'
#df[,y] <- df[,y]*160 # perform for substrate (dividing by 160 produces strange results)
# call model
out <- zipFunc(df, xs, y, printAll=T)
######################
# Pois/ZIP
######################
# setup xs and y (only change these lines)
df <- dfo
#xs <- b
xs <- b[b != "AQUARIUM.FISH.COLLECTION"] # o, a, b
y <- 'SNAPPER'
#df[,y] <- df[,y]*160 # perform for substrate (dividing by 160 produces strange results)
# call model
out <- zipFunc(df, xs, y, printAll=T)
par(mfrow=c(1,1))
######################
# Pois/ZIP
######################
# setup xs and y (only change these lines)
df <- dfo
#xs <- b
xs <- b[b != "AQUARIUM.FISH.COLLECTION"] # o, a, b
y <- 'SNAPPER'
#df[,y] <- df[,y]*160 # perform for substrate (dividing by 160 produces strange results)
# call model
out <- zipFunc(df, xs, y, printAll=T)
# round response variable and remove
df[,y] <- as.integer(round(df[,y])) # convert all counts to ints
df <- subset(df, !is.na(df[,y])) # drop na in y var
xs <- xs[!xs %in% c(y)] # remove var from formula
# create formula
xs <- paste(xs, collapse="+")
formula <- formula(paste(c(y, xs), collapse='~'))
if (printAll) print(formula)
# create train and test split
sample = sample.split(df[,y], SplitRatio = .75)
train = subset(df, sample == TRUE)
test  = subset(df, sample == FALSE)
# run model
fit <- zeroinfl(formula, data = train, dist = 'poisson')
if (printAll) print(summary(fit))
# get correlation
pred <- round(predict(fit, newdata=test))
######################
# Pois/ZIP
######################
# setup xs and y (only change these lines)
df <- dfo
#xs <- b
xs <- b[b != "AQUARIUM.FISH.COLLECTION"] # o, a, b
y <- 'SNAPPER'
#df[,y] <- df[,y]*160 # perform for substrate (dividing by 160 produces strange results)
# call model
out <- zipFunc(df, xs, y, printAll=T)
# round response variable and remove
df[,y] <- as.integer(round(df[,y])) # convert all counts to ints
df <- subset(df, !is.na(df[,y])) # drop na in y var
xs <- xs[!xs %in% c(y)] # remove var from formula
# create formula
xs <- paste(xs, collapse="+")
formula <- formula(paste(c(y, xs), collapse='~'))
if (printAll) print(formula)
# create train and test split
sample = sample.split(df[,y], SplitRatio = .75)
train = subset(df, sample == TRUE)
test  = subset(df, sample == FALSE)
# run model
fit <- zeroinfl(formula, data = train, dist = 'poisson')
if (printAll) print(summary(fit))
# get correlation
pred <- round(predict(fit, newdata=test))
rsquare <- cor(pred, test[,y], use = "complete.obs")
corStr = paste0(c('cor',round(rsquare, 3)), collapse = ': ')
print(corStr)
plot(pred, test[,y], main=paste(c(y,'predicted against true')), xlab='yhat', ylab='y')
abline(lm(test[,y] ~ pred), col="red") # regression line (y~x)
qqplot(pred, test[,y])
# round response variable and remove
df[,y] <- as.integer(round(df[,y])) # convert all counts to ints
df <- subset(df, !is.na(df[,y])) # drop na in y var
xs <- xs[!xs %in% c(y)] # remove var from formula
# create formula
xs <- paste(xs, collapse="+")
formula <- formula(paste(c(y, xs), collapse='~'))
if (printAll) print(formula)
# create train and test split
sample = sample.split(df[,y], SplitRatio = .75)
train = subset(df, sample == TRUE)
test  = subset(df, sample == FALSE)
# run model
fit <- zeroinfl(formula, data = train, dist = 'poisson')
if (printAll) print(summary(fit))
plot(pred, test[,y], main=paste(c(y,'predicted against true')), xlab='yhat', ylab='y')
abline(lm(test[,y] ~ pred), col="red") # regression line (y~x)
text(x = 8, y = max(test[,y])-10, corStr, col = 'red', cex=0.8)#labels=paste0(c('r^2: ',rsquare)))
qqplot(pred, test[,y])
qqplot(pred, test[,y], main='Snapper qqplot Predicted vs. True')
levels(df$SEWAGE.POLLUTION)
levels(df$SILTATION)
levels(df$POISON.FISHING)
plot(summary(fit))
plot(fit)
fit
# Author: Michael Berk, James Johndrow
# Date: Spring 2020
# Purpose: develop explanatory models of species counts using RC data
#####################
# get Helpers.R
#####################
# set wd and df based on user
if (dir.exists("/Users/michaelberk")) {
setwd('~/Documents/Penn 2019-2020/Senior Thesis/Scripts/ReefCheckModeling/')
} else {
setwd('~/Dropbox/Projects/Reefs/')
}
# run helpers
source("Code/Helpers.R")
# run MICE (only run once)
# createMICE()
######################
# variable setup
######################
# get all y variables to be modeled
targetVars <- c('HC','SC','RK','NI','SNAPPER','LOBSTER','PARROTFISH','GROUPER.TOTAL',
'BUTTERFLYFISH','PENCIL.URCHIN')
# setup data
#dfo <- loadDF()
#dfm <- loadDF(MICE=T)
# get all x-variable subsets
o <- c(subsetCols('organism'), "WATER.TEMP.AT.SURFACE")  # organism
a <- c(subsetCols('anthro'), "WATER.TEMP.AT.SURFACE") # anthropogenic
b <- c(a, o)[1:(length(c(a,o))-1)] # both
######################
# Pois/ZIP
######################
# setup xs and y (only change these lines)
df <- dfo
xs <- a
#xs <- b[b != "AQUARIUM.FISH.COLLECTION"] # o, a, b
y <- 'LOBSTER'
#df[,y] <-
# round response variable and remove
if (y %in% c(subsetCols('organism'))) {
df[,y] <- as.integer(round(df[,y])) # round all counts
}
df <- subset(df, !is.na(df[,y])) # drop na in y var
xs <- xs[!xs %in% c(y)] # remove var from formula
# create formula
xs <- paste(xs, collapse="+")
formula <- formula(paste(c(y, xs), collapse='~'))
if (printAll) print(formula)
# create train and test split
sample = sample.split(df[,y], SplitRatio = .75)
train = subset(df, sample == TRUE)
test  = subset(df, sample == FALSE)
# run model
fit <- randomForest(formula, data = train, na.action=na.roughfix)
if (printAll) print(fit)
par(mfrow=c(2,2))
for (c in c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {
partialPlot(fit, train[!is.na(train[,c]),], c,
xlab = c, ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", c)),
cex.main=1.2,
cex.lab=1.2)
}
names(train)
train[,"TOURIST.DIVING.SNORKELING"]
train[,CORAL.DAMAGE.OTHER"]
train[,"CORAL.DAMAGE.OTHER"]
train[,"SEWAGE.POLLUTION"]
train[,"HARVEST.OF.INVERTS.FOR.FOOD"]
for (c in c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {
partialPlot(fit, train[!is.na(train[,c]),], c,
xlab = c, ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", c)),
cex.main=1.2,
cex.lab=1.2)
}
partialPlot(fit, train[!is.na(train[,c]),], c,
xlab = c, ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", c)),
cex.main=1.2,
cex.lab=1.2)
c
train[!is.na(train[,c]),]
par(mfrow=c(2,2))
xs <- unlist(strsplit(xs, "[+]"))
for (i in 1:length(xs)) {
if (xs[i] %in% c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {
#if (xs[i] %in% c("PARROTFISH", "DIADEMA","SNAPPER","GROUPER.TOTAL")) {
partialPlot(fit, train[!is.na(train[,xs[i]]),], xs[i],
xlab = xs[i], ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", xs[i])),
cex.main=1.2,
cex.lab=1.2)
}
}
for (i in c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {
partialPlot(fit, train[!is.na(train[,i]),], i,
xlab = i, ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", i)),
cex.main=1.2,
cex.lab=1.2)
}
for (i in c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {
partialPlot(fit, train[!is.na(train[i]),], i,
xlab = i, ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", i)),
cex.main=1.2,
cex.lab=1.2)
}
train[i]
summary(train[i])
for (i in c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {
partialPlot(fit, train[!is.na(train[get(i)]),], i,
xlab = i, ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", i)),
cex.main=1.2,
cex.lab=1.2)
}
for (i in c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {
partialPlot(fit, train[!is.na(train[i]),], i,
xlab = i, ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", i)),
cex.main=1.2,
cex.lab=1.2)
}
for (i in c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {
partialPlot(fit, train[!is.na(train["TOURIST.DIVING.SNORKELING"]),], i,
xlab = i, ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", i)),
cex.main=1.2,
cex.lab=1.2)
}
for (i in c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {
partialPlot(fit, train[!is.na(train[,"TOURIST.DIVING.SNORKELING"]),], i,
xlab = i, ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", i)),
cex.main=1.2,
cex.lab=1.2)
}
i
for (i in c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {
partialPlot(fit, train[!is.na(train[,"TOURIST.DIVING.SNORKELING"]),], i,
xlab = i, ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", i)),
cex.main=1.2,
cex.lab=1.2)
}
train[!is.na(train[,"TOURIST.DIVING.SNORKELING"]),]
for (i in c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD")) {
d <- train[!is.na(train[,"TOURIST.DIVING.SNORKELING"]),]
print(d)
partialPlot(fit, d, i,
xlab = i, ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", i)),
cex.main=1.2,
cex.lab=1.2)
}
partialPlot(fit, d, i,
xlab = i, ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", i)),
cex.main=1.2,
cex.lab=1.2)
partialPlot(fit, d,
xlab = i, ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", i)),
cex.main=1.2,
cex.lab=1.2)
partialPlot(fit, d, t,
xlab = i, ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", i)),
cex.main=1.2,
cex.lab=1.2)
partialPlot(fit, d, y,
xlab = i, ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", i)),
cex.main=1.2,
cex.lab=1.2)
idxs <- match(c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD"),x)
idxs <- match(c("TOURIST.DIVING.SNORKELING", "CORAL.DAMAGE.OTHER","SEWAGE.POLLUTION","HARVEST.OF.INVERTS.FOR.FOOD"),xs)
idxs
# iterate through and plot
for (i in idxs) {
partialPlot(fit, train[!is.na(train[,xs[i]]),], xs[i],
xlab = xs[i], ylab = y,
main = paste0(c("Partial Dependence of ", y, " vs. ", xs[i])),
cex.main=1.2,
cex.lab=1.2)
}
levels(df$TOURIST.DIVING.SNORKELING)
summary(df$LOBSTER)
table(df$LOBSTER)
dim9df
dim(df)
8900/10158
